function [ new_state, new_memory, collided, stop ] = SnakeTailVer7( state, memory, params, non_participating )
	%SNAKETAILVER5 simulate snake tail algorithm with 2 bit memory in the agents only !
	% setting 3 is essential, otherwise cells are colliding when both above and below are 2-s
	% input direction
	north = 1; east = 2; south = 3; west = 4;
	% agent decision	
	go_north = north - 1; go_east = east - 1; go_south = south - 1; go_west = west - 1;
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%             TABLE              %
	% ------------------------------ %
	% | 3 |       | 7 |        | 4 | %
	% -----       -----        ----- %
	% |                            | %
	% -----       -----        ----- %
	% | 6 |       | 9 |        | 8 | %
	% -----       -----        ----- %
	% |                            | %
	% -----       -----        ----- %
	% | 2 |       | 5 |        | 1 | %
	% ------------------------------ %
	%                                %
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	% prepare memory and direction mapping
	do_nothing = go_west + 1; error = do_nothing + 1; 
	map_memory = GetMemoryMap();
	map_direction = GetDirectionMap();

	% neighborhoods
	m_0_down = boolean([0;0;1]);
	m_0_up = boolean([1;0;0]);
	m_0_right = m_0_down';
	m_0_left = m_0_up';
	
	% everyone in
	if(nargin < 4)
		non_participating = zeros(size(state));
	end
	
	% areas
	where_zeros = state == params.no_vehicle;
	zeros_on = cell(west - north + 1,1);
	
	zeros_on{north} = Conv2(where_zeros, m_0_down, 'same') & ~non_participating; % to the north of the cell
	zeros_on{east} = Conv2(where_zeros, m_0_left, 'same') & ~non_participating; % to the east of the cell
	zeros_on{south} = Conv2(where_zeros, m_0_up, 'same') & ~non_participating; % to the south of the cell
	zeros_on{west} = Conv2(where_zeros, m_0_right, 'same') & ~non_participating; % to the west of the cell
	
	
	indexes = (1:numel(state))';
	movement_possibilities = cell(go_west - go_north + 1, 1);
	for direction = go_north:go_west
		movement_possibilities{direction + 1} = indexes(zeros_on{direction + 1});
	end

	stop = false;
	collided = false;
	new_state = state;
	new_memory = memory;
	
	directions = cell(go_west - go_north + 1, 1);
	area_map = MapAreas(params);
	for direction = north:west
		directions{direction} = map_direction(memory(zeros_on{direction}) + 1, direction, area_map(zeros_on{direction}));
		if(Any(directions{direction} == error))
			fprintf('The table is in the wrong state\n');
			stop = true;
			return;
		end
	end
	
	after_movement = zeros(size(state));
	actual_moving_indexes = cell(west - north + 1, 1);
	
	% index offsets
	offset = [-1; params.n; 1; -params.n];
	for direction = go_north:go_west
		move_possibilities = movement_possibilities{direction + 1};
		actual_indexes_to_move = move_possibilities(directions{direction + 1} == direction);
		actual_moving_indexes{direction + 1} = actual_indexes_to_move;
		staying_indexes = move_possibilities(directions{direction + 1} == do_nothing);
		if(~isempty(actual_indexes_to_move))
			after_movement(actual_indexes_to_move + offset(direction + 1)) = after_movement(actual_indexes_to_move + offset(direction + 1)) + 1;
			new_state(actual_indexes_to_move + offset(direction + 1)) = state(actual_indexes_to_move);
			new_state(actual_indexes_to_move) = params.no_vehicle;
		end
		
		new_memory(actual_indexes_to_move + offset(direction + 1)) = GetEntries(map_memory, memory, direction + 1, area_map, move_possibilities);
		new_memory(actual_indexes_to_move) = 0;
		new_memory(staying_indexes) = GetEntries(map_memory, memory, direction + 1, area_map, staying_indexes);
	end

	if(Any(after_movement > 1))
		collided = true;
		return;
	end
	
	if(any(ismember(actual_moving_indexes{south}, 1)) || ...
			((params.m ~= 1) && any(ismember(actual_moving_indexes{north}, params.n)) && (memory(end, 1) == 2)) || ...
			((params.n == 1) && any(ismember(actual_moving_indexes, 1))))
		stop = true;
	end
end

function [result_memory_map] = GetMemoryMap()
	persistent memory_map;
	error = 5;
	
	if(isempty(memory_map))
		memory_map = error * ones(4, 4, 9); % 5 is when no input is given

		memory_map(:, :, 1) = [ ...
			2, error, error, 0; ...
			error, error, error, error; ...
			error, error, error, 3; ...
			3, error, error, 3];
		memory_map(:, :, 2) = [ ...
			1, 1, error, error; ...
			2, 2, error, error; ...
			3, 3, error, error; ...
			3, 1, error, error];
		memory_map(:, :, 3) = [ ...
			error, 1, 1, error; ...
			error, 2, 2, error; ...
			error, 3, 3, error; ...
			error, 2, 3, error];
		memory_map(:, :, 4) = [ ...
			error, error, 2, 0; ...
			error, error, 2, error; ...
			error, error, 3, error; ...
			error, error, 3, 3];
		memory_map(:, :, 5) = [ ...
			0, 1, error, 0; ...
			2, 2, error, 1; ...
			3, 3, error, 2; ...
			3, 2, error, 3];
		memory_map(:, :, 6) = [ ...
			0, 2, 1, error; ...
			2, 2, 2, error; ...
			3, 2, 3, error; ...
			3, 2, 3, error];
		memory_map(:, :, 7) = [ ...
			error, 1, 1, 0; ...
			error, 2, 2, 1; ...
			error, 3, 3, 2; ...
			error, 2, 3, 3];
		memory_map(:, :, 8) = [ ...
			1, error, 2, 0; ...
			error, error, 2, error; ...
			error, error, 3, error; ...
			3, error, 3, 3];
		memory_map(:, :, 9) = [ ...
			0, 2, 2, 0; ...
			2, 2, 2, 1; ...
			3, 2, 3, 2; ...
			3, 2, 3, 3];
	end
	
	result_memory_map = memory_map;
end

function [result_direction_map] = GetDirectionMap()
	persistent direction_map;
	
	if(isempty(direction_map))
		error = 5;
		do_nothing = 4;
		% direction
		north = 0; east = 1; south = 2; west = 3;
		% agent decision	
		go_north = north; go_east = east; go_south = south; go_west = west;
		direction_map = error * ones(4, 4, 9);

		direction_map(:, :, 1) = [ ...
			go_north, error, error, go_west; ...
			error, error, error, error; ...
			error, error, error, do_nothing; ...
			do_nothing, error, error, do_nothing];
		direction_map(:, :, 2) = [ ...
			go_north, do_nothing, error, error; ...
			do_nothing, do_nothing, error, error; ...
			go_north, go_east, error, error; ...
			do_nothing, do_nothing, error, error];
		direction_map(:, :, 3) = [ ...
			error, do_nothing, do_nothing, error; ...
			error, do_nothing, do_nothing, error; ...
			error, go_east, go_south, error; ...
			error, do_nothing, do_nothing, error];
		direction_map(:, :, 4) = [ ...
			error, error, do_nothing, do_nothing; ...
			error, error, do_nothing, error; ...
			error, error, go_south, error; ...
			error, error, go_south, do_nothing];
		direction_map(:, :, 5) = [ ...
			go_north, do_nothing, error, go_west; ...
			do_nothing, do_nothing, error, do_nothing; ...
			go_north, go_east, error, do_nothing; ...
			do_nothing, do_nothing, error, do_nothing];
		direction_map(:, :, 6) = [ ...
			go_north, do_nothing, do_nothing, error; ...
			do_nothing, do_nothing, do_nothing, error; ...
			go_north, do_nothing, go_south, error; ...
			do_nothing, do_nothing, do_nothing, error];
		direction_map(:, :, 7) = [ ...
			error, do_nothing, do_nothing, do_nothing; ...
			error, do_nothing, do_nothing, do_nothing; ...
			error, go_east, go_south, do_nothing; ...
			error, do_nothing, do_nothing, do_nothing];
		direction_map(:, :, 8) = [ ...
			go_north, error, do_nothing, do_nothing; ...
			error, error, do_nothing, error; ...
			error, error, go_south, error; ...
			do_nothing, error, go_south, do_nothing];
		direction_map(:, :, 9) = [ ...
			go_north, do_nothing, do_nothing, do_nothing; ...
			do_nothing, do_nothing, do_nothing, do_nothing; ...
			go_north, do_nothing, go_south, do_nothing; ...
			do_nothing, do_nothing, do_nothing, do_nothing];
	end

	result_direction_map = direction_map;
end

function [area_index] = MapAreas(params)
	% masks
	first_row = false(params.n, params.m); first_row(1,:) = true;
	last_row = false(size(first_row)); last_row(end,:) = true;
	first_column = false(size(first_row)); first_column(:, 1) = true;
	last_column = false(size(first_row)); last_column(:, end) = true;
	left_upper_corner = false(size(first_row)); left_upper_corner(1,1) = true;
	right_upper_corner = false(size(first_row)); right_upper_corner(1,end) = true;
	right_bottom_corner = false(size(first_row)); right_bottom_corner(end,end) = true;
	left_bottom_corner = false(size(first_row)); left_bottom_corner(end,1) = true;
	
	[rows, cols] = size(first_row);
	
	area_index = ...
		1 * right_bottom_corner + ...
		2 * (cols > 1 && rows > 1) * left_bottom_corner + ...
		3 * left_upper_corner + ...
		4 * (cols > 1 && rows > 1) * right_upper_corner + ...
		5 * (cols > 2) * (last_row & ~(right_bottom_corner | left_bottom_corner)) + ...
		6 * (cols > 1 && rows > 2) * (first_column & ~(left_bottom_corner | left_upper_corner)) + ...
		7 * (cols > 2 && rows > 1) * (first_row & ~(left_upper_corner | right_upper_corner)) + ...
		8 * (rows > 2) * (last_column & ~(right_upper_corner | right_bottom_corner)) + ...
		9 * (cols > 2 && rows > 2) * (~(first_column | first_row | last_column | last_row));
end

function [anyset] = Any(m)
	anyset =  any(any(m));
end

function [ConvB] = Conv2(M1, M2, type)
	ConvB = boolean(conv2(double(M1), double(M2), type));
end

function [values] = GetEntries(map, memory, input_direction, area_map, entries)
	if(isempty(entries))
		values = double.empty(size(entries));
	else
		sizes = size(map);
		indexes = sub2ind(sizes, memory(entries) + 1, input_direction * ones(numel(area_map(entries)), 1), area_map(entries));
		values = map(indexes);
	end
end
