function [ new_state, new_memory, collided, stop ] = MultipleSnakeTailVer1( state, memory, params )
	%SNAKETAILVER5 simulate snake tail algorithm with 2 bit memory in the agents only !
	% setting 3 is essential, otherwise cells are colliding when both above and below are 2-s
	% input direction
	north = 0; east = 1; south = 2; west = 3;
	% agent decision	
	go_north = north; go_east = east; go_south = south; go_west = west;
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%             TABLE              %
	% ------------------------------ %
	% | 3 |       | 7 |        | 4 | %
	% -----       -----        ----- %
	% |                            | %
	% -----       -----        ----- %
	% | 6 |       | 9 |        | 8 | %
	% -----       -----        ----- %
	% |                            | %
	% -----       -----        ----- %
	% | 2 |       | 5 |        | 1 | %
	% ------------------------------ %
	%                                %
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	% prepare memory and direction mapping
	error = 5; do_nothing = 4; empty_direction = -1;
	map_memory = GetMemoryMap();
	map_direction = GetDirectionMap();
	mapping = GetDirectionMapping();

	% neighborhoods
	m_0_down = boolean([0;0;1]);
	m_0_up = boolean([1;0;0]);
	m_0_right = m_0_down';
	m_0_left = m_0_up';
	
	% areas
	where_zeros = state == params.no_vehicle;
	where_zeros_above = Conv2(where_zeros, m_0_down, 'same'); % to the north of the cell
	where_zeros_below = Conv2(where_zeros, m_0_up, 'same'); % to the south of the cell
	where_zeros_onleft = Conv2(where_zeros, m_0_right, 'same'); % to the west of the cell
	where_zeros_onright = Conv2(where_zeros, m_0_left, 'same'); % to the east of the cell
	
	where_zeros_num = uint8(1 + 1 * where_zeros_above + 2 * where_zeros_onright + ...
		4 * where_zeros_below + 8 * where_zeros_onleft);
	
	indexes = (1:numel(state))';

	stop = false;
	collided = false;
	new_state = state;
	new_memory = memory;
	
	area_map = MapAreas(params);
	direction_indexes = mapping(sub2ind(size(mapping), area_map(:), where_zeros_num(:)));
	debug_indexes = [memory(:) + 1, direction_indexes, area_map(:)];
	current_directions = map_direction(sub2ind(size(map_direction), memory(:) + 1, direction_indexes, area_map(:)));
	current_directions(where_zeros) = empty_direction;
	
	if(Any(current_directions == error))
		fprintf('The table is in the wrong state\n');
		stop = true;
		return;
	end
	
	after_movement = zeros(numel(state), 1);
	
	shift_in = [-1;params.n;1;-params.n];
	for direction = go_north:go_west
		actual_indexes_moving = indexes(current_directions == direction);
		after_movement(actual_indexes_moving + shift_in(direction + 1)) = ...
			after_movement(actual_indexes_moving + shift_in(direction + 1)) + 1;
		new_state(actual_indexes_moving + shift_in(direction + 1) ) = state(actual_indexes_moving);
		new_state(actual_indexes_moving) = params.no_vehicle;
	end
	
	if(Any(after_movement > 1))
		collided = true;
		return;
	end	
	
	new_memory = map_memory(sub2ind(size(map_memory), memory(:) + 1, direction_indexes, area_map(:)));	
	zero_indexes = indexes(where_zeros);
	future_occupied_zeros = false(size(zero_indexes));
	
	for direction = go_north:go_west
		actual_indexes_moving = indexes(current_directions == direction);
		future_occupied_zeros = future_occupied_zeros | ismember(zero_indexes, actual_indexes_moving + shift_in(direction + 1));
		new_memory(actual_indexes_moving + shift_in(direction + 1)) = new_memory(actual_indexes_moving);
		new_memory(actual_indexes_moving) = 0;
	end
	
	new_memory(zero_indexes(~future_occupied_zeros)) = 0;
	new_memory = reshape(new_memory, params.n, params.m);
	if(~Any(state ~= new_state) && ~Any(memory ~= new_memory))
		stop = true;
	end
	
end

function [result_lookup] = GetDirectionMapping()
	persistent direction_mapping;
	
	if(isempty(direction_mapping))
		empty = 1; north = 2; east = 3; south = 5; west = 9;
		north_east = 4; north_south = 6; north_west = 10;
		east_south = 7; east_west = 11; south_west = 13;
		north_east_south = 8; north_east_west = 12; north_south_west = 14;
		east_south_west = 15; every = 16;
		
		direction_mapping = -1 * ones(9, 16);
		direction_mapping(:, empty) = 1;
		
		direction_mapping(1, [north,  west, north_west]) = 2:4;
		direction_mapping(2, [north,  east, north_east]) = 2:4;
		direction_mapping(3, [ east, south, east_south]) = 2:4;
		direction_mapping(4, [south,  west, south_west]) = 2:4;
		direction_mapping(5, [north,  east,  west,  north_east,  north_west,  east_west,  north_east_west]) = 2:8;
		direction_mapping(6, [north,  east, south,  north_east, north_south, east_south, north_east_south]) = 2:8;
		direction_mapping(7, [ east, south,  west,  east_south,   east_west, south_west,  east_south_west]) = 2:8;
		direction_mapping(8, [north, south,  west, north_south,  north_west, south_west, north_south_west]) = 2:8;
		direction_mapping(9, [north, east, south, west, north_east, north_south, north_west, east_south ...
			east_west, south_west, north_east_south, north_east_west, north_south_west, east_south_west, every]) = ...
			[2, 1, 3, 1, 2, 4, 2, 3, 1, 3, 4, 2, 4, 3, 4];
	end
	
	result_lookup = direction_mapping;
end

function [result_memory_map] = GetMemoryMap()
	persistent memory_map;
	error = 5;
	
	if(isempty(memory_map))
		memory_map = error * ones(4, 16, 9); % 5 is when no input is given

		memory_map(:, 1:4, 1) = [ ...
			0, 2, 1, 2; ...
			1, error, error, error; ...
			2, 2, 2, 2; ...
			error, error, error, error];
		memory_map(:, 1:4, 2) = [ ...
			0, 2, 3, 2; ...
			1, 1, 3, 3; ...
			0, 2, 1, 1; ...
			0, 3, 2, 2];
		memory_map(:, 1:4, 3) = [ ...
			0, 1, 1, 1; ...
			1, 2, 2, 2; ...
			2, 1, 3, 3; ...
			3, 3, 2, 2];
		memory_map(:, 1:4, 4) = [ ...
			0, 1, 0, 1; ...
			1, 2, 1, 2; ...
			2, 3, 2, 3; ...
			3, 2, 3, 2];
		memory_map(:, 1:8, 5) = [ ...
			0, 2, 3, 1, 2, 2, 3, 2; ...
			1, 1, 3, 1, 3, 1, 3, 3; ...
			2, 2, 1, 2, 1, 2, 1, 1; ...
			0, 3, 2, 3, 2, 3, 2, 2];
		memory_map(:, 1:8, 6) = [ ...
			0, 2, 0, 1, 2, 2, 1, 2; ...
			1, 2, 1, 2, 2, 2, 2, 2; ...
			2, 2, 2, 3, 2, 3, 3, 3; ...
			3, 3, 3, 2, 3, 2, 2, 2];
		memory_map(:, 1:8, 7) = [ ...
			0, 1, 1, 0, 1, 1, 1, 1; ...
			0, 2, 2, 1, 2, 2, 2, 2; ...
			2, 1, 3, 2, 1, 1, 3, 1; ...
			3, 1, 2, 3, 1, 1, 2, 1];
		memory_map(:, 1:8, 8) = [ ...
			0, 2, 1, 0, 2, 2, 1, 2; ...
			1, 2, 2, 1, 2, 2, 2, 2; ...
			2, 2, 3, 2, 3, 2, 3, 3; ...
			3, 3, 2, 3, 2, 3, 2, 2];
		memory_map(:, 1:4, 9) = [ ...
			0, 2, 1, 2; ...
			1, 2, 2, 2; ...
			2, 2, 3, 3; ...
			3, 3, 2, 2];
	end
	
	result_memory_map = memory_map;
end

function [result_direction_map] = GetDirectionMap()
	persistent direction_map;
	
	if(isempty(direction_map))
		error = 5;
		do_nothing = 4;
		% direction
		north = 0; east = 1; south = 2; west = 3;
		% agent decision	
		go_north = north; go_east = east; go_south = south; go_west = west;
		direction_map = error * ones(4, 16, 9);

		direction_map(:, 1:4, 1) = [ ...
			do_nothing, go_north, go_west, go_north; ...
			do_nothing, error, error, error; ...
			do_nothing, do_nothing, do_nothing, do_nothing; ...
			error, error, error, error];
		direction_map(:, 1:4, 2) = [ ...
			do_nothing, go_north, do_nothing, go_north; ...
			do_nothing, do_nothing, do_nothing, do_nothing; ...
			do_nothing, do_nothing, go_east, go_east; ...
			do_nothing, do_nothing, do_nothing, do_nothing];
		direction_map(:, 1:4, 3) = [ ...
			do_nothing, do_nothing, do_nothing, do_nothing; ...
			do_nothing, go_east, go_south, go_south; ...
			do_nothing, do_nothing, do_nothing, do_nothing; ...
			do_nothing, do_nothing, go_south, go_south];
		direction_map(:, 1:4, 4) = [ ...
			do_nothing, do_nothing, do_nothing, do_nothing; ...
			do_nothing,   go_south, do_nothing,   go_south; ...
			do_nothing, do_nothing, do_nothing, do_nothing; ...
			do_nothing,   go_south, do_nothing,   go_south];
		direction_map(:, 1:8, 5) = [ ...
			do_nothing, go_north, do_nothing, go_west, go_north, go_north, do_nothing, go_north; ...
			do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing; ...
			do_nothing, do_nothing, go_east, do_nothing, go_east, do_nothing, go_east, go_east; ...
			do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing];
		direction_map(:, 1:8, 6) = [ ...
			do_nothing, go_north, do_nothing, do_nothing, go_north, go_north, do_nothing, go_north; ...
			do_nothing, go_north, do_nothing, go_south, go_north, go_north, go_south, go_north; ...
			do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing; ...
			do_nothing, do_nothing, do_nothing, go_south, do_nothing, go_south, go_south, go_south];
		direction_map(:, 1:8, 7) = [ ...
			do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing; ...
			do_nothing, go_east, go_south, do_nothing, go_south, go_east, go_south, go_south; ...
			do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing; ...
			do_nothing, do_nothing, go_south, do_nothing, do_nothing, do_nothing, go_south, do_nothing];
		direction_map(:, 1:8, 8) = [ ...
			do_nothing, go_north, do_nothing, do_nothing, go_north, go_north, do_nothing, go_north; ...
			do_nothing, go_north, go_south, do_nothing, go_north, go_north, go_south, go_north; ...
			do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing, do_nothing; ...
			do_nothing, do_nothing, go_south, do_nothing, go_south, do_nothing, go_south, go_south];
		direction_map(:, 1:4, 9) = [ ...
			do_nothing, go_north, do_nothing, go_north; ...
			do_nothing, go_north, go_south, go_north; ...
			do_nothing, do_nothing, do_nothing, do_nothing; ...
			do_nothing, do_nothing, go_south, go_south];
	end

	result_direction_map = direction_map;
end

function [area_index] = MapAreas(params)
	% masks
	first_row = false(params.n, params.m); first_row(1,:) = true;
	last_row = false(size(first_row)); last_row(end,:) = true;
	first_column = false(size(first_row)); first_column(:, 1) = true;
	last_column = false(size(first_row)); last_column(:, end) = true;
	left_upper_corner = false(size(first_row)); left_upper_corner(1,1) = true;
	right_upper_corner = false(size(first_row)); right_upper_corner(1,end) = true;
	right_bottom_corner = false(size(first_row)); right_bottom_corner(end,end) = true;
	left_bottom_corner = false(size(first_row)); left_bottom_corner(end,1) = true;
	
	[rows, cols] = size(first_row);
	
	area_index = ...
		1 * right_bottom_corner + ...
		2 * (cols > 1 && rows > 1) * left_bottom_corner + ...
		3 * left_upper_corner + ...
		4 * (cols > 1 && rows > 1) * right_upper_corner + ...
		5 * (cols > 2) * (last_row & ~(right_bottom_corner | left_bottom_corner)) + ...
		6 * (cols > 1 && rows > 2) * (first_column & ~(left_bottom_corner | left_upper_corner)) + ...
		7 * (cols > 2 && rows > 1) * (first_row & ~(left_upper_corner | right_upper_corner)) + ...
		8 * (rows > 2) * (last_column & ~(right_upper_corner | right_bottom_corner)) + ...
		9 * (cols > 2 && rows > 2) * (~(first_column | first_row | last_column | last_row));
end

function [anyset] = Any(m)
	anyset =  any(any(m));
end

function [ConvB] = Conv2(M1, M2, type)
	ConvB = boolean(conv2(double(M1), double(M2), type));
end
